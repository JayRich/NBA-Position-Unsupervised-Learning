# -*- coding: utf-8 -*-
"""nba_cluster.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/11xnrIBSZcx29WvDkwlV_6J0HGRUDV4cT
"""

# Commented out IPython magic to ensure Python compatibility.
# Jason Richardson 

!wget -O 2018-2019_NBA_Stats.csv https://uta.instructure.com/courses/61673/files/10505095/preview?verifier=1qoqyIxNj5MjnRrfNGQsUpWHAQs0TDZiyDLfTKps

from sklearn import cluster
import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
import io
import pandas as pd
from sklearn import preprocessing
from sklearn.model_selection import train_test_split
from sklearn.model_selection import cross_val_score
from sklearn.metrics import classification_report
from sklearn import cluster
from scipy.cluster.hierarchy import dendrogram
from sklearn.cluster import KMeans
import matplotlib.pyplot as plt
from sklearn import metrics
from sklearn.metrics import plot_roc_curve
import matplotlib.pyplot as plt
from scipy.cluster.hierarchy import dendrogram
# %matplotlib inline

#Read from the csv file and return a Pandas DataFrame.
stats_file = '/content/2018-2019_NBA_Stats.csv'
nba = pd.read_csv(io.FileIO(stats_file))

class_column = 'Position'

feature_columns = ['Points Per Game','Blocks Per Game']       # set desired features for k means

# set desired features for agglomerative
agglomerative_feature_columns = ['Games Played', 'Minutes Per Game',\
                   'Points Per Game', 'Total Rebounds Per Game',\
                   'Assists Per Game', 'Three Points Made Per Game',\
                   'Steals Per Game', 'Blocks Per Game', 'Turnovers Per Game']

nba_feature = nba[feature_columns]
agg_nba_feature = nba[agglomerative_feature_columns]
nba_class = nba[class_column]
labels_true = nba['Position']


k_means_model = cluster.KMeans(n_clusters=2, max_iter=50, random_state=1)       # define model hyper-parameters for k means
k_means_model.fit(nba_feature)                                              # train k means
labels_pred = k_means_model.labels_                                           # get an array of model predictions for k means
print("----------------------------------")
print("K means: ")
# compute evaluation measures
silhouette = metrics.silhouette_score(nba_feature, labels_pred, metric='euclidean')       # I focus on Silhouette because I'm trying to discover new classifications of data from clusters and can therefore ignore ground truth measures 
print("Silhouette Coefficient: " + str(silhouette))
rand = metrics.adjusted_rand_score(labels_true, labels_pred)
mi = metrics.normalized_mutual_info_score(labels_true, labels_pred) 
print("Adjusted Rand Index: " + str(rand))
print("Normalized Mutual Information: " + str(mi))
print("------------------------------------")

# function for plotting agglomerative dendogram
def plot_dendrogram(model, **kwargs):
    # Create linkage matrix and then plot the dendrogram

    # create the counts of samples under each node
    counts = np.zeros(model.children_.shape[0])
    n_samples = len(model.labels_)
    for i, merge in enumerate(model.children_):
        current_count = 0
        for child_idx in merge:
            if child_idx < n_samples:
                current_count += 1  # leaf node
            else:
                current_count += counts[child_idx - n_samples]
        counts[i] = current_count

    linkage_matrix = np.column_stack([model.children_, model.distances_,
                                      counts]).astype(float)

    # Plot the corresponding dendrogram
    dendrogram(linkage_matrix, **kwargs)

agglomerative_model = cluster.AgglomerativeClustering(linkage='single', affinity='manhattan', distance_threshold=0, n_clusters=None)
agglomerative_model.fit(agg_nba_feature)
labels_pred = agglomerative_model.labels_ 
print("Agglomerative: ")
plt.title('Hierarchical Clustering Dendrogram: ')
# plot the top five levels of the dendrogram
plot_dendrogram(agglomerative_model, truncate_mode='level', p=8, labels=nba_class.tolist(), orientation='right')
plt.xlabel("Number of points in node (or index of point if no parenthesis).")
plt.show()
print("-----------------------------------")